/* 
 * virusapi
 *
 * The Cloudmersive Virus Scan API lets you scan files and content for viruses and identify security issues with content.
 *
 * OpenAPI spec version: v1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using Cloudmersive.APIClient.NET.VirusScan.Client;
using Cloudmersive.APIClient.NET.VirusScan.Model;

namespace Cloudmersive.APIClient.NET.VirusScan.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IScanApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Scan a file for viruses
        /// </summary>
        /// <remarks>
        /// Scan files and content for viruses. Leverage continuously updated signatures for millions of threats, and advanced high-performance scanning capabilities.  Over 17 million virus and malware signatures.  Continuous cloud-based updates.  Wide file format support including Office, PDF, HTML, Flash.  Zip support including .Zip, .Rar, .DMG, .Tar, and other archive formats.  Multi-threat scanning across viruses, malware, trojans, ransomware, and spyware.  High-speed in-memory scanning delivers subsecond typical response time.
        /// </remarks>
        /// <exception cref="Cloudmersive.APIClient.NET.VirusScan.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inputFile">Input file to perform the operation on.</param>
        /// <returns>VirusScanResult</returns>
        VirusScanResult ScanFile (System.IO.Stream inputFile);

        /// <summary>
        /// Scan a file for viruses
        /// </summary>
        /// <remarks>
        /// Scan files and content for viruses. Leverage continuously updated signatures for millions of threats, and advanced high-performance scanning capabilities.  Over 17 million virus and malware signatures.  Continuous cloud-based updates.  Wide file format support including Office, PDF, HTML, Flash.  Zip support including .Zip, .Rar, .DMG, .Tar, and other archive formats.  Multi-threat scanning across viruses, malware, trojans, ransomware, and spyware.  High-speed in-memory scanning delivers subsecond typical response time.
        /// </remarks>
        /// <exception cref="Cloudmersive.APIClient.NET.VirusScan.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inputFile">Input file to perform the operation on.</param>
        /// <returns>ApiResponse of VirusScanResult</returns>
        ApiResponse<VirusScanResult> ScanFileWithHttpInfo (System.IO.Stream inputFile);
        /// <summary>
        /// Advanced Scan a file for viruses
        /// </summary>
        /// <remarks>
        /// Advanced Scan files with 360-degree Content Protection across Viruses and Malware, executables, invalid files, scripts, and even restrictions on accepted file types with complete content verification. Customize threat rules to your needs. Leverage continuously updated signatures for millions of threats, and advanced high-performance scanning capabilities.  Over 17 million virus and malware signatures.  Continuous cloud-based updates.  Block threats beyond viruses including executables, scripts, invalid files, and more.  Optionally limit input files to a specific set of file types (e.g. PDF and Word Documents only).  Wide file format support including Office, PDF, HTML, Flash.  Zip support including .Zip, .Rar, .DMG, .Tar, and other archive formats.  Multi-threat scanning across viruses, malware, trojans, ransomware, and spyware.  High-speed in-memory scanning delivers subsecond typical response time.
        /// </remarks>
        /// <exception cref="Cloudmersive.APIClient.NET.VirusScan.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inputFile">Input file to perform the operation on.</param>
        /// <param name="allowExecutables">Set to false to block executable files (program code) from being allowed in the input file.  Default is false (recommended). (optional)</param>
        /// <param name="allowInvalidFiles">Set to false to block invalid files, such as a PDF file that is not really a valid PDF file, or a Word Document that is not a valid Word Document.  Default is false (recommended). (optional)</param>
        /// <param name="allowScripts">Set to false to block script files, such as a PHP files, Pythong scripts, and other malicious content or security threats that can be embedded in the file.  Set to true to allow these file types.  Default is false (recommended). (optional)</param>
        /// <param name="allowPasswordProtectedFiles">Set to false to block password protected and encrypted files, such as encrypted zip and rar files, and other files that seek to circumvent scanning through passwords.  Set to true to allow these file types.  Default is false (recommended). (optional)</param>
        /// <param name="restrictFileTypes">Specify a restricted set of file formats to allow as clean as a comma-separated list of file formats, such as .pdf,.docx,.png would allow only PDF, PNG and Word document files.  All files must pass content verification against this list of file formats, if they do not, then the result will be returned as CleanResult&#x3D;false.  Set restrictFileTypes parameter to null or empty string to disable; default is disabled. (optional)</param>
        /// <returns>VirusScanAdvancedResult</returns>
        VirusScanAdvancedResult ScanFileAdvanced (System.IO.Stream inputFile, bool? allowExecutables = null, bool? allowInvalidFiles = null, bool? allowScripts = null, bool? allowPasswordProtectedFiles = null, string restrictFileTypes = null);

        /// <summary>
        /// Advanced Scan a file for viruses
        /// </summary>
        /// <remarks>
        /// Advanced Scan files with 360-degree Content Protection across Viruses and Malware, executables, invalid files, scripts, and even restrictions on accepted file types with complete content verification. Customize threat rules to your needs. Leverage continuously updated signatures for millions of threats, and advanced high-performance scanning capabilities.  Over 17 million virus and malware signatures.  Continuous cloud-based updates.  Block threats beyond viruses including executables, scripts, invalid files, and more.  Optionally limit input files to a specific set of file types (e.g. PDF and Word Documents only).  Wide file format support including Office, PDF, HTML, Flash.  Zip support including .Zip, .Rar, .DMG, .Tar, and other archive formats.  Multi-threat scanning across viruses, malware, trojans, ransomware, and spyware.  High-speed in-memory scanning delivers subsecond typical response time.
        /// </remarks>
        /// <exception cref="Cloudmersive.APIClient.NET.VirusScan.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inputFile">Input file to perform the operation on.</param>
        /// <param name="allowExecutables">Set to false to block executable files (program code) from being allowed in the input file.  Default is false (recommended). (optional)</param>
        /// <param name="allowInvalidFiles">Set to false to block invalid files, such as a PDF file that is not really a valid PDF file, or a Word Document that is not a valid Word Document.  Default is false (recommended). (optional)</param>
        /// <param name="allowScripts">Set to false to block script files, such as a PHP files, Pythong scripts, and other malicious content or security threats that can be embedded in the file.  Set to true to allow these file types.  Default is false (recommended). (optional)</param>
        /// <param name="allowPasswordProtectedFiles">Set to false to block password protected and encrypted files, such as encrypted zip and rar files, and other files that seek to circumvent scanning through passwords.  Set to true to allow these file types.  Default is false (recommended). (optional)</param>
        /// <param name="restrictFileTypes">Specify a restricted set of file formats to allow as clean as a comma-separated list of file formats, such as .pdf,.docx,.png would allow only PDF, PNG and Word document files.  All files must pass content verification against this list of file formats, if they do not, then the result will be returned as CleanResult&#x3D;false.  Set restrictFileTypes parameter to null or empty string to disable; default is disabled. (optional)</param>
        /// <returns>ApiResponse of VirusScanAdvancedResult</returns>
        ApiResponse<VirusScanAdvancedResult> ScanFileAdvancedWithHttpInfo (System.IO.Stream inputFile, bool? allowExecutables = null, bool? allowInvalidFiles = null, bool? allowScripts = null, bool? allowPasswordProtectedFiles = null, string restrictFileTypes = null);
        /// <summary>
        /// Scan a website for malicious content and threats
        /// </summary>
        /// <remarks>
        /// Operation includes scanning the content of the URL for various types of malicious content and threats, including viruses and threats (including Phishing).
        /// </remarks>
        /// <exception cref="Cloudmersive.APIClient.NET.VirusScan.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="input"></param>
        /// <returns>WebsiteScanResult</returns>
        WebsiteScanResult ScanWebsite (WebsiteScanRequest input);

        /// <summary>
        /// Scan a website for malicious content and threats
        /// </summary>
        /// <remarks>
        /// Operation includes scanning the content of the URL for various types of malicious content and threats, including viruses and threats (including Phishing).
        /// </remarks>
        /// <exception cref="Cloudmersive.APIClient.NET.VirusScan.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="input"></param>
        /// <returns>ApiResponse of WebsiteScanResult</returns>
        ApiResponse<WebsiteScanResult> ScanWebsiteWithHttpInfo (WebsiteScanRequest input);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Scan a file for viruses
        /// </summary>
        /// <remarks>
        /// Scan files and content for viruses. Leverage continuously updated signatures for millions of threats, and advanced high-performance scanning capabilities.  Over 17 million virus and malware signatures.  Continuous cloud-based updates.  Wide file format support including Office, PDF, HTML, Flash.  Zip support including .Zip, .Rar, .DMG, .Tar, and other archive formats.  Multi-threat scanning across viruses, malware, trojans, ransomware, and spyware.  High-speed in-memory scanning delivers subsecond typical response time.
        /// </remarks>
        /// <exception cref="Cloudmersive.APIClient.NET.VirusScan.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inputFile">Input file to perform the operation on.</param>
        /// <returns>Task of VirusScanResult</returns>
        System.Threading.Tasks.Task<VirusScanResult> ScanFileAsync (System.IO.Stream inputFile);

        /// <summary>
        /// Scan a file for viruses
        /// </summary>
        /// <remarks>
        /// Scan files and content for viruses. Leverage continuously updated signatures for millions of threats, and advanced high-performance scanning capabilities.  Over 17 million virus and malware signatures.  Continuous cloud-based updates.  Wide file format support including Office, PDF, HTML, Flash.  Zip support including .Zip, .Rar, .DMG, .Tar, and other archive formats.  Multi-threat scanning across viruses, malware, trojans, ransomware, and spyware.  High-speed in-memory scanning delivers subsecond typical response time.
        /// </remarks>
        /// <exception cref="Cloudmersive.APIClient.NET.VirusScan.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inputFile">Input file to perform the operation on.</param>
        /// <returns>Task of ApiResponse (VirusScanResult)</returns>
        System.Threading.Tasks.Task<ApiResponse<VirusScanResult>> ScanFileAsyncWithHttpInfo (System.IO.Stream inputFile);
        /// <summary>
        /// Advanced Scan a file for viruses
        /// </summary>
        /// <remarks>
        /// Advanced Scan files with 360-degree Content Protection across Viruses and Malware, executables, invalid files, scripts, and even restrictions on accepted file types with complete content verification. Customize threat rules to your needs. Leverage continuously updated signatures for millions of threats, and advanced high-performance scanning capabilities.  Over 17 million virus and malware signatures.  Continuous cloud-based updates.  Block threats beyond viruses including executables, scripts, invalid files, and more.  Optionally limit input files to a specific set of file types (e.g. PDF and Word Documents only).  Wide file format support including Office, PDF, HTML, Flash.  Zip support including .Zip, .Rar, .DMG, .Tar, and other archive formats.  Multi-threat scanning across viruses, malware, trojans, ransomware, and spyware.  High-speed in-memory scanning delivers subsecond typical response time.
        /// </remarks>
        /// <exception cref="Cloudmersive.APIClient.NET.VirusScan.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inputFile">Input file to perform the operation on.</param>
        /// <param name="allowExecutables">Set to false to block executable files (program code) from being allowed in the input file.  Default is false (recommended). (optional)</param>
        /// <param name="allowInvalidFiles">Set to false to block invalid files, such as a PDF file that is not really a valid PDF file, or a Word Document that is not a valid Word Document.  Default is false (recommended). (optional)</param>
        /// <param name="allowScripts">Set to false to block script files, such as a PHP files, Pythong scripts, and other malicious content or security threats that can be embedded in the file.  Set to true to allow these file types.  Default is false (recommended). (optional)</param>
        /// <param name="allowPasswordProtectedFiles">Set to false to block password protected and encrypted files, such as encrypted zip and rar files, and other files that seek to circumvent scanning through passwords.  Set to true to allow these file types.  Default is false (recommended). (optional)</param>
        /// <param name="restrictFileTypes">Specify a restricted set of file formats to allow as clean as a comma-separated list of file formats, such as .pdf,.docx,.png would allow only PDF, PNG and Word document files.  All files must pass content verification against this list of file formats, if they do not, then the result will be returned as CleanResult&#x3D;false.  Set restrictFileTypes parameter to null or empty string to disable; default is disabled. (optional)</param>
        /// <returns>Task of VirusScanAdvancedResult</returns>
        System.Threading.Tasks.Task<VirusScanAdvancedResult> ScanFileAdvancedAsync (System.IO.Stream inputFile, bool? allowExecutables = null, bool? allowInvalidFiles = null, bool? allowScripts = null, bool? allowPasswordProtectedFiles = null, string restrictFileTypes = null);

        /// <summary>
        /// Advanced Scan a file for viruses
        /// </summary>
        /// <remarks>
        /// Advanced Scan files with 360-degree Content Protection across Viruses and Malware, executables, invalid files, scripts, and even restrictions on accepted file types with complete content verification. Customize threat rules to your needs. Leverage continuously updated signatures for millions of threats, and advanced high-performance scanning capabilities.  Over 17 million virus and malware signatures.  Continuous cloud-based updates.  Block threats beyond viruses including executables, scripts, invalid files, and more.  Optionally limit input files to a specific set of file types (e.g. PDF and Word Documents only).  Wide file format support including Office, PDF, HTML, Flash.  Zip support including .Zip, .Rar, .DMG, .Tar, and other archive formats.  Multi-threat scanning across viruses, malware, trojans, ransomware, and spyware.  High-speed in-memory scanning delivers subsecond typical response time.
        /// </remarks>
        /// <exception cref="Cloudmersive.APIClient.NET.VirusScan.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inputFile">Input file to perform the operation on.</param>
        /// <param name="allowExecutables">Set to false to block executable files (program code) from being allowed in the input file.  Default is false (recommended). (optional)</param>
        /// <param name="allowInvalidFiles">Set to false to block invalid files, such as a PDF file that is not really a valid PDF file, or a Word Document that is not a valid Word Document.  Default is false (recommended). (optional)</param>
        /// <param name="allowScripts">Set to false to block script files, such as a PHP files, Pythong scripts, and other malicious content or security threats that can be embedded in the file.  Set to true to allow these file types.  Default is false (recommended). (optional)</param>
        /// <param name="allowPasswordProtectedFiles">Set to false to block password protected and encrypted files, such as encrypted zip and rar files, and other files that seek to circumvent scanning through passwords.  Set to true to allow these file types.  Default is false (recommended). (optional)</param>
        /// <param name="restrictFileTypes">Specify a restricted set of file formats to allow as clean as a comma-separated list of file formats, such as .pdf,.docx,.png would allow only PDF, PNG and Word document files.  All files must pass content verification against this list of file formats, if they do not, then the result will be returned as CleanResult&#x3D;false.  Set restrictFileTypes parameter to null or empty string to disable; default is disabled. (optional)</param>
        /// <returns>Task of ApiResponse (VirusScanAdvancedResult)</returns>
        System.Threading.Tasks.Task<ApiResponse<VirusScanAdvancedResult>> ScanFileAdvancedAsyncWithHttpInfo (System.IO.Stream inputFile, bool? allowExecutables = null, bool? allowInvalidFiles = null, bool? allowScripts = null, bool? allowPasswordProtectedFiles = null, string restrictFileTypes = null);
        /// <summary>
        /// Scan a website for malicious content and threats
        /// </summary>
        /// <remarks>
        /// Operation includes scanning the content of the URL for various types of malicious content and threats, including viruses and threats (including Phishing).
        /// </remarks>
        /// <exception cref="Cloudmersive.APIClient.NET.VirusScan.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="input"></param>
        /// <returns>Task of WebsiteScanResult</returns>
        System.Threading.Tasks.Task<WebsiteScanResult> ScanWebsiteAsync (WebsiteScanRequest input);

        /// <summary>
        /// Scan a website for malicious content and threats
        /// </summary>
        /// <remarks>
        /// Operation includes scanning the content of the URL for various types of malicious content and threats, including viruses and threats (including Phishing).
        /// </remarks>
        /// <exception cref="Cloudmersive.APIClient.NET.VirusScan.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="input"></param>
        /// <returns>Task of ApiResponse (WebsiteScanResult)</returns>
        System.Threading.Tasks.Task<ApiResponse<WebsiteScanResult>> ScanWebsiteAsyncWithHttpInfo (WebsiteScanRequest input);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class ScanApi : IScanApi
    {
        private Cloudmersive.APIClient.NET.VirusScan.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="ScanApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ScanApi(String basePath)
        {
            this.Configuration = new Cloudmersive.APIClient.NET.VirusScan.Client.Configuration { BasePath = basePath };

            ExceptionFactory = Cloudmersive.APIClient.NET.VirusScan.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ScanApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public ScanApi(Cloudmersive.APIClient.NET.VirusScan.Client.Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = Cloudmersive.APIClient.NET.VirusScan.Client.Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = Cloudmersive.APIClient.NET.VirusScan.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Cloudmersive.APIClient.NET.VirusScan.Client.Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Cloudmersive.APIClient.NET.VirusScan.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Scan a file for viruses Scan files and content for viruses. Leverage continuously updated signatures for millions of threats, and advanced high-performance scanning capabilities.  Over 17 million virus and malware signatures.  Continuous cloud-based updates.  Wide file format support including Office, PDF, HTML, Flash.  Zip support including .Zip, .Rar, .DMG, .Tar, and other archive formats.  Multi-threat scanning across viruses, malware, trojans, ransomware, and spyware.  High-speed in-memory scanning delivers subsecond typical response time.
        /// </summary>
        /// <exception cref="Cloudmersive.APIClient.NET.VirusScan.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inputFile">Input file to perform the operation on.</param>
        /// <returns>VirusScanResult</returns>
        public VirusScanResult ScanFile (System.IO.Stream inputFile)
        {
             ApiResponse<VirusScanResult> localVarResponse = ScanFileWithHttpInfo(inputFile);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Scan a file for viruses Scan files and content for viruses. Leverage continuously updated signatures for millions of threats, and advanced high-performance scanning capabilities.  Over 17 million virus and malware signatures.  Continuous cloud-based updates.  Wide file format support including Office, PDF, HTML, Flash.  Zip support including .Zip, .Rar, .DMG, .Tar, and other archive formats.  Multi-threat scanning across viruses, malware, trojans, ransomware, and spyware.  High-speed in-memory scanning delivers subsecond typical response time.
        /// </summary>
        /// <exception cref="Cloudmersive.APIClient.NET.VirusScan.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inputFile">Input file to perform the operation on.</param>
        /// <returns>ApiResponse of VirusScanResult</returns>
        public ApiResponse< VirusScanResult > ScanFileWithHttpInfo (System.IO.Stream inputFile)
        {
            // verify the required parameter 'inputFile' is set
            if (inputFile == null)
                throw new ApiException(400, "Missing required parameter 'inputFile' when calling ScanApi->ScanFile");

            var localVarPath = "/virus/scan/file";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "multipart/form-data"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "text/json",
                "application/xml",
                "text/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (inputFile != null) localVarFileParams.Add("inputFile", this.Configuration.ApiClient.ParameterToFile("inputFile", inputFile));

            // authentication (Apikey) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Apikey")))
            {
                localVarHeaderParams["Apikey"] = this.Configuration.GetApiKeyWithPrefix("Apikey");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ScanFile", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<VirusScanResult>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (VirusScanResult) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(VirusScanResult)));
        }

        /// <summary>
        /// Scan a file for viruses Scan files and content for viruses. Leverage continuously updated signatures for millions of threats, and advanced high-performance scanning capabilities.  Over 17 million virus and malware signatures.  Continuous cloud-based updates.  Wide file format support including Office, PDF, HTML, Flash.  Zip support including .Zip, .Rar, .DMG, .Tar, and other archive formats.  Multi-threat scanning across viruses, malware, trojans, ransomware, and spyware.  High-speed in-memory scanning delivers subsecond typical response time.
        /// </summary>
        /// <exception cref="Cloudmersive.APIClient.NET.VirusScan.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inputFile">Input file to perform the operation on.</param>
        /// <returns>Task of VirusScanResult</returns>
        public async System.Threading.Tasks.Task<VirusScanResult> ScanFileAsync (System.IO.Stream inputFile)
        {
             ApiResponse<VirusScanResult> localVarResponse = await ScanFileAsyncWithHttpInfo(inputFile);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Scan a file for viruses Scan files and content for viruses. Leverage continuously updated signatures for millions of threats, and advanced high-performance scanning capabilities.  Over 17 million virus and malware signatures.  Continuous cloud-based updates.  Wide file format support including Office, PDF, HTML, Flash.  Zip support including .Zip, .Rar, .DMG, .Tar, and other archive formats.  Multi-threat scanning across viruses, malware, trojans, ransomware, and spyware.  High-speed in-memory scanning delivers subsecond typical response time.
        /// </summary>
        /// <exception cref="Cloudmersive.APIClient.NET.VirusScan.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inputFile">Input file to perform the operation on.</param>
        /// <returns>Task of ApiResponse (VirusScanResult)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<VirusScanResult>> ScanFileAsyncWithHttpInfo (System.IO.Stream inputFile)
        {
            // verify the required parameter 'inputFile' is set
            if (inputFile == null)
                throw new ApiException(400, "Missing required parameter 'inputFile' when calling ScanApi->ScanFile");

            var localVarPath = "/virus/scan/file";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "multipart/form-data"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "text/json",
                "application/xml",
                "text/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (inputFile != null) localVarFileParams.Add("inputFile", this.Configuration.ApiClient.ParameterToFile("inputFile", inputFile));

            // authentication (Apikey) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Apikey")))
            {
                localVarHeaderParams["Apikey"] = this.Configuration.GetApiKeyWithPrefix("Apikey");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ScanFile", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<VirusScanResult>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (VirusScanResult) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(VirusScanResult)));
        }

        /// <summary>
        /// Advanced Scan a file for viruses Advanced Scan files with 360-degree Content Protection across Viruses and Malware, executables, invalid files, scripts, and even restrictions on accepted file types with complete content verification. Customize threat rules to your needs. Leverage continuously updated signatures for millions of threats, and advanced high-performance scanning capabilities.  Over 17 million virus and malware signatures.  Continuous cloud-based updates.  Block threats beyond viruses including executables, scripts, invalid files, and more.  Optionally limit input files to a specific set of file types (e.g. PDF and Word Documents only).  Wide file format support including Office, PDF, HTML, Flash.  Zip support including .Zip, .Rar, .DMG, .Tar, and other archive formats.  Multi-threat scanning across viruses, malware, trojans, ransomware, and spyware.  High-speed in-memory scanning delivers subsecond typical response time.
        /// </summary>
        /// <exception cref="Cloudmersive.APIClient.NET.VirusScan.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inputFile">Input file to perform the operation on.</param>
        /// <param name="allowExecutables">Set to false to block executable files (program code) from being allowed in the input file.  Default is false (recommended). (optional)</param>
        /// <param name="allowInvalidFiles">Set to false to block invalid files, such as a PDF file that is not really a valid PDF file, or a Word Document that is not a valid Word Document.  Default is false (recommended). (optional)</param>
        /// <param name="allowScripts">Set to false to block script files, such as a PHP files, Pythong scripts, and other malicious content or security threats that can be embedded in the file.  Set to true to allow these file types.  Default is false (recommended). (optional)</param>
        /// <param name="allowPasswordProtectedFiles">Set to false to block password protected and encrypted files, such as encrypted zip and rar files, and other files that seek to circumvent scanning through passwords.  Set to true to allow these file types.  Default is false (recommended). (optional)</param>
        /// <param name="restrictFileTypes">Specify a restricted set of file formats to allow as clean as a comma-separated list of file formats, such as .pdf,.docx,.png would allow only PDF, PNG and Word document files.  All files must pass content verification against this list of file formats, if they do not, then the result will be returned as CleanResult&#x3D;false.  Set restrictFileTypes parameter to null or empty string to disable; default is disabled. (optional)</param>
        /// <returns>VirusScanAdvancedResult</returns>
        public VirusScanAdvancedResult ScanFileAdvanced (System.IO.Stream inputFile, bool? allowExecutables = null, bool? allowInvalidFiles = null, bool? allowScripts = null, bool? allowPasswordProtectedFiles = null, string restrictFileTypes = null)
        {
             ApiResponse<VirusScanAdvancedResult> localVarResponse = ScanFileAdvancedWithHttpInfo(inputFile, allowExecutables, allowInvalidFiles, allowScripts, allowPasswordProtectedFiles, restrictFileTypes);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Advanced Scan a file for viruses Advanced Scan files with 360-degree Content Protection across Viruses and Malware, executables, invalid files, scripts, and even restrictions on accepted file types with complete content verification. Customize threat rules to your needs. Leverage continuously updated signatures for millions of threats, and advanced high-performance scanning capabilities.  Over 17 million virus and malware signatures.  Continuous cloud-based updates.  Block threats beyond viruses including executables, scripts, invalid files, and more.  Optionally limit input files to a specific set of file types (e.g. PDF and Word Documents only).  Wide file format support including Office, PDF, HTML, Flash.  Zip support including .Zip, .Rar, .DMG, .Tar, and other archive formats.  Multi-threat scanning across viruses, malware, trojans, ransomware, and spyware.  High-speed in-memory scanning delivers subsecond typical response time.
        /// </summary>
        /// <exception cref="Cloudmersive.APIClient.NET.VirusScan.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inputFile">Input file to perform the operation on.</param>
        /// <param name="allowExecutables">Set to false to block executable files (program code) from being allowed in the input file.  Default is false (recommended). (optional)</param>
        /// <param name="allowInvalidFiles">Set to false to block invalid files, such as a PDF file that is not really a valid PDF file, or a Word Document that is not a valid Word Document.  Default is false (recommended). (optional)</param>
        /// <param name="allowScripts">Set to false to block script files, such as a PHP files, Pythong scripts, and other malicious content or security threats that can be embedded in the file.  Set to true to allow these file types.  Default is false (recommended). (optional)</param>
        /// <param name="allowPasswordProtectedFiles">Set to false to block password protected and encrypted files, such as encrypted zip and rar files, and other files that seek to circumvent scanning through passwords.  Set to true to allow these file types.  Default is false (recommended). (optional)</param>
        /// <param name="restrictFileTypes">Specify a restricted set of file formats to allow as clean as a comma-separated list of file formats, such as .pdf,.docx,.png would allow only PDF, PNG and Word document files.  All files must pass content verification against this list of file formats, if they do not, then the result will be returned as CleanResult&#x3D;false.  Set restrictFileTypes parameter to null or empty string to disable; default is disabled. (optional)</param>
        /// <returns>ApiResponse of VirusScanAdvancedResult</returns>
        public ApiResponse< VirusScanAdvancedResult > ScanFileAdvancedWithHttpInfo (System.IO.Stream inputFile, bool? allowExecutables = null, bool? allowInvalidFiles = null, bool? allowScripts = null, bool? allowPasswordProtectedFiles = null, string restrictFileTypes = null)
        {
            // verify the required parameter 'inputFile' is set
            if (inputFile == null)
                throw new ApiException(400, "Missing required parameter 'inputFile' when calling ScanApi->ScanFileAdvanced");

            var localVarPath = "/virus/scan/file/advanced";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "multipart/form-data"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "text/json",
                "application/xml",
                "text/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (allowExecutables != null) localVarHeaderParams.Add("allowExecutables", this.Configuration.ApiClient.ParameterToString(allowExecutables)); // header parameter
            if (allowInvalidFiles != null) localVarHeaderParams.Add("allowInvalidFiles", this.Configuration.ApiClient.ParameterToString(allowInvalidFiles)); // header parameter
            if (allowScripts != null) localVarHeaderParams.Add("allowScripts", this.Configuration.ApiClient.ParameterToString(allowScripts)); // header parameter
            if (allowPasswordProtectedFiles != null) localVarHeaderParams.Add("allowPasswordProtectedFiles", this.Configuration.ApiClient.ParameterToString(allowPasswordProtectedFiles)); // header parameter
            if (restrictFileTypes != null) localVarHeaderParams.Add("restrictFileTypes", this.Configuration.ApiClient.ParameterToString(restrictFileTypes)); // header parameter
            if (inputFile != null) localVarFileParams.Add("inputFile", this.Configuration.ApiClient.ParameterToFile("inputFile", inputFile));

            // authentication (Apikey) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Apikey")))
            {
                localVarHeaderParams["Apikey"] = this.Configuration.GetApiKeyWithPrefix("Apikey");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ScanFileAdvanced", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<VirusScanAdvancedResult>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (VirusScanAdvancedResult) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(VirusScanAdvancedResult)));
        }

        /// <summary>
        /// Advanced Scan a file for viruses Advanced Scan files with 360-degree Content Protection across Viruses and Malware, executables, invalid files, scripts, and even restrictions on accepted file types with complete content verification. Customize threat rules to your needs. Leverage continuously updated signatures for millions of threats, and advanced high-performance scanning capabilities.  Over 17 million virus and malware signatures.  Continuous cloud-based updates.  Block threats beyond viruses including executables, scripts, invalid files, and more.  Optionally limit input files to a specific set of file types (e.g. PDF and Word Documents only).  Wide file format support including Office, PDF, HTML, Flash.  Zip support including .Zip, .Rar, .DMG, .Tar, and other archive formats.  Multi-threat scanning across viruses, malware, trojans, ransomware, and spyware.  High-speed in-memory scanning delivers subsecond typical response time.
        /// </summary>
        /// <exception cref="Cloudmersive.APIClient.NET.VirusScan.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inputFile">Input file to perform the operation on.</param>
        /// <param name="allowExecutables">Set to false to block executable files (program code) from being allowed in the input file.  Default is false (recommended). (optional)</param>
        /// <param name="allowInvalidFiles">Set to false to block invalid files, such as a PDF file that is not really a valid PDF file, or a Word Document that is not a valid Word Document.  Default is false (recommended). (optional)</param>
        /// <param name="allowScripts">Set to false to block script files, such as a PHP files, Pythong scripts, and other malicious content or security threats that can be embedded in the file.  Set to true to allow these file types.  Default is false (recommended). (optional)</param>
        /// <param name="allowPasswordProtectedFiles">Set to false to block password protected and encrypted files, such as encrypted zip and rar files, and other files that seek to circumvent scanning through passwords.  Set to true to allow these file types.  Default is false (recommended). (optional)</param>
        /// <param name="restrictFileTypes">Specify a restricted set of file formats to allow as clean as a comma-separated list of file formats, such as .pdf,.docx,.png would allow only PDF, PNG and Word document files.  All files must pass content verification against this list of file formats, if they do not, then the result will be returned as CleanResult&#x3D;false.  Set restrictFileTypes parameter to null or empty string to disable; default is disabled. (optional)</param>
        /// <returns>Task of VirusScanAdvancedResult</returns>
        public async System.Threading.Tasks.Task<VirusScanAdvancedResult> ScanFileAdvancedAsync (System.IO.Stream inputFile, bool? allowExecutables = null, bool? allowInvalidFiles = null, bool? allowScripts = null, bool? allowPasswordProtectedFiles = null, string restrictFileTypes = null)
        {
             ApiResponse<VirusScanAdvancedResult> localVarResponse = await ScanFileAdvancedAsyncWithHttpInfo(inputFile, allowExecutables, allowInvalidFiles, allowScripts, allowPasswordProtectedFiles, restrictFileTypes);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Advanced Scan a file for viruses Advanced Scan files with 360-degree Content Protection across Viruses and Malware, executables, invalid files, scripts, and even restrictions on accepted file types with complete content verification. Customize threat rules to your needs. Leverage continuously updated signatures for millions of threats, and advanced high-performance scanning capabilities.  Over 17 million virus and malware signatures.  Continuous cloud-based updates.  Block threats beyond viruses including executables, scripts, invalid files, and more.  Optionally limit input files to a specific set of file types (e.g. PDF and Word Documents only).  Wide file format support including Office, PDF, HTML, Flash.  Zip support including .Zip, .Rar, .DMG, .Tar, and other archive formats.  Multi-threat scanning across viruses, malware, trojans, ransomware, and spyware.  High-speed in-memory scanning delivers subsecond typical response time.
        /// </summary>
        /// <exception cref="Cloudmersive.APIClient.NET.VirusScan.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="inputFile">Input file to perform the operation on.</param>
        /// <param name="allowExecutables">Set to false to block executable files (program code) from being allowed in the input file.  Default is false (recommended). (optional)</param>
        /// <param name="allowInvalidFiles">Set to false to block invalid files, such as a PDF file that is not really a valid PDF file, or a Word Document that is not a valid Word Document.  Default is false (recommended). (optional)</param>
        /// <param name="allowScripts">Set to false to block script files, such as a PHP files, Pythong scripts, and other malicious content or security threats that can be embedded in the file.  Set to true to allow these file types.  Default is false (recommended). (optional)</param>
        /// <param name="allowPasswordProtectedFiles">Set to false to block password protected and encrypted files, such as encrypted zip and rar files, and other files that seek to circumvent scanning through passwords.  Set to true to allow these file types.  Default is false (recommended). (optional)</param>
        /// <param name="restrictFileTypes">Specify a restricted set of file formats to allow as clean as a comma-separated list of file formats, such as .pdf,.docx,.png would allow only PDF, PNG and Word document files.  All files must pass content verification against this list of file formats, if they do not, then the result will be returned as CleanResult&#x3D;false.  Set restrictFileTypes parameter to null or empty string to disable; default is disabled. (optional)</param>
        /// <returns>Task of ApiResponse (VirusScanAdvancedResult)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<VirusScanAdvancedResult>> ScanFileAdvancedAsyncWithHttpInfo (System.IO.Stream inputFile, bool? allowExecutables = null, bool? allowInvalidFiles = null, bool? allowScripts = null, bool? allowPasswordProtectedFiles = null, string restrictFileTypes = null)
        {
            // verify the required parameter 'inputFile' is set
            if (inputFile == null)
                throw new ApiException(400, "Missing required parameter 'inputFile' when calling ScanApi->ScanFileAdvanced");

            var localVarPath = "/virus/scan/file/advanced";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "multipart/form-data"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "text/json",
                "application/xml",
                "text/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (allowExecutables != null) localVarHeaderParams.Add("allowExecutables", this.Configuration.ApiClient.ParameterToString(allowExecutables)); // header parameter
            if (allowInvalidFiles != null) localVarHeaderParams.Add("allowInvalidFiles", this.Configuration.ApiClient.ParameterToString(allowInvalidFiles)); // header parameter
            if (allowScripts != null) localVarHeaderParams.Add("allowScripts", this.Configuration.ApiClient.ParameterToString(allowScripts)); // header parameter
            if (allowPasswordProtectedFiles != null) localVarHeaderParams.Add("allowPasswordProtectedFiles", this.Configuration.ApiClient.ParameterToString(allowPasswordProtectedFiles)); // header parameter
            if (restrictFileTypes != null) localVarHeaderParams.Add("restrictFileTypes", this.Configuration.ApiClient.ParameterToString(restrictFileTypes)); // header parameter
            if (inputFile != null) localVarFileParams.Add("inputFile", this.Configuration.ApiClient.ParameterToFile("inputFile", inputFile));

            // authentication (Apikey) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Apikey")))
            {
                localVarHeaderParams["Apikey"] = this.Configuration.GetApiKeyWithPrefix("Apikey");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ScanFileAdvanced", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<VirusScanAdvancedResult>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (VirusScanAdvancedResult) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(VirusScanAdvancedResult)));
        }

        /// <summary>
        /// Scan a website for malicious content and threats Operation includes scanning the content of the URL for various types of malicious content and threats, including viruses and threats (including Phishing).
        /// </summary>
        /// <exception cref="Cloudmersive.APIClient.NET.VirusScan.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="input"></param>
        /// <returns>WebsiteScanResult</returns>
        public WebsiteScanResult ScanWebsite (WebsiteScanRequest input)
        {
             ApiResponse<WebsiteScanResult> localVarResponse = ScanWebsiteWithHttpInfo(input);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Scan a website for malicious content and threats Operation includes scanning the content of the URL for various types of malicious content and threats, including viruses and threats (including Phishing).
        /// </summary>
        /// <exception cref="Cloudmersive.APIClient.NET.VirusScan.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="input"></param>
        /// <returns>ApiResponse of WebsiteScanResult</returns>
        public ApiResponse< WebsiteScanResult > ScanWebsiteWithHttpInfo (WebsiteScanRequest input)
        {
            // verify the required parameter 'input' is set
            if (input == null)
                throw new ApiException(400, "Missing required parameter 'input' when calling ScanApi->ScanWebsite");

            var localVarPath = "/virus/scan/website";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json", 
                "text/json", 
                "application/xml", 
                "text/xml", 
                "application/x-www-form-urlencoded"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "text/json",
                "application/xml",
                "text/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (input != null && input.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(input); // http body (model) parameter
            }
            else
            {
                localVarPostBody = input; // byte array
            }

            // authentication (Apikey) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Apikey")))
            {
                localVarHeaderParams["Apikey"] = this.Configuration.GetApiKeyWithPrefix("Apikey");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ScanWebsite", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<WebsiteScanResult>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (WebsiteScanResult) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(WebsiteScanResult)));
        }

        /// <summary>
        /// Scan a website for malicious content and threats Operation includes scanning the content of the URL for various types of malicious content and threats, including viruses and threats (including Phishing).
        /// </summary>
        /// <exception cref="Cloudmersive.APIClient.NET.VirusScan.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="input"></param>
        /// <returns>Task of WebsiteScanResult</returns>
        public async System.Threading.Tasks.Task<WebsiteScanResult> ScanWebsiteAsync (WebsiteScanRequest input)
        {
             ApiResponse<WebsiteScanResult> localVarResponse = await ScanWebsiteAsyncWithHttpInfo(input);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Scan a website for malicious content and threats Operation includes scanning the content of the URL for various types of malicious content and threats, including viruses and threats (including Phishing).
        /// </summary>
        /// <exception cref="Cloudmersive.APIClient.NET.VirusScan.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="input"></param>
        /// <returns>Task of ApiResponse (WebsiteScanResult)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<WebsiteScanResult>> ScanWebsiteAsyncWithHttpInfo (WebsiteScanRequest input)
        {
            // verify the required parameter 'input' is set
            if (input == null)
                throw new ApiException(400, "Missing required parameter 'input' when calling ScanApi->ScanWebsite");

            var localVarPath = "/virus/scan/website";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json", 
                "text/json", 
                "application/xml", 
                "text/xml", 
                "application/x-www-form-urlencoded"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "text/json",
                "application/xml",
                "text/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (input != null && input.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(input); // http body (model) parameter
            }
            else
            {
                localVarPostBody = input; // byte array
            }

            // authentication (Apikey) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Apikey")))
            {
                localVarHeaderParams["Apikey"] = this.Configuration.GetApiKeyWithPrefix("Apikey");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ScanWebsite", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<WebsiteScanResult>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (WebsiteScanResult) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(WebsiteScanResult)));
        }

    }
}
